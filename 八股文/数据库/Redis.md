### 1、redis支持哪些数据类型？

Redis支持五种数据类型：
* string(字符串)
* hash(哈希) 
* list(列表)
* set(集合)
* zset(sorted set:有序集合)

### 2、zset底层数据结构是什么，查询时间复杂度和删除的时间复杂度分别是多少？

zset底层的存储结构包括`ziplist`或`skiplist`，在**同时**满足以下两个条件的时候使用ziplist，其他时候使用skiplist(跳表)：

* 有序集合保存的元素数量小于128个；
* 有序集合保存的所有元素的长度小于64字节；

时间复杂度

* ziplist：本质类似一个双向链表，时间复杂度为O(N)
* skiplist：跳表的实现，其实和二分查找的思路相似，查询、插入、删除的时间复杂度均为O(logN)

参考：https://juejin.cn/post/6863258283483807752

### 3、hash/list/set的底层数据结构是什么？

* [hash](https://www.cnblogs.com/reecelin/p/13362104.html) ：底层实现有两种，元素较小或数量较少时使用`zipList`，元素较多时使用`dict`，即hashtable
* [list](https://www.cnblogs.com/reecelin/p/13358432.html) ：元素较小或数量较少时使用`zipList`，元素较多时会转而使用双向链表`linkedList`
* [set](https://www.cnblogs.com/reecelin/p/13364089.html) ：底层实现有两种
    * 当value是整数值时，且数据量不大时使用`inset`来存储
    * 其他情况都是用`dict`即hashtable来存储
  
![](https://github.com/SongLee24/LeetCode-Go/blob/main/%E5%85%AB%E8%82%A1%E6%96%87/images/redis-base-struct.jpg?raw=true)

### 4、Redis为什么是单线程的？

注意：redis 单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块仍用了多个线程。

因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。既然CPU不会成为瓶颈，单线程也避免了不必要的上下文切换和竞争条件，那就顺理成章地采用单线程的方案了。

### 5、单线程的Redis为什么这么快？

1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中；
2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
4. 使用多路I/O复用模型，非阻塞IO；

### 6、为什么Redis需要把所有数据放到内存中？

Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以Redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响Redis的性能。在内存越来越便宜的今天，Redis将会越来越受欢迎。

如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

### 7、Redis三种删除策略和六种淘汰策略？

删除策略：

1. 定时删除：在设置键的过期时间的同时，创建⼀个定时器，当键达到过期时间时，⽴即执⾏对键的删除操作；
2. 惰性删除：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，不返回任何东西；如
果没有过期，就返回该键；
3. 定期删除：每隔⼀点时间，程序就对数据库进⾏⼀次检查，删除⾥⾯的过期键，⾄于要删除多少过期键，以及要检查多少个数据库，则由
算法决定。默认每隔100ms随机抽取⼀些设计过期时间的key去检查是否过期。
   
淘汰策略：

1. 【noeviction】不删除策略，达到最⼤内存，再插⼊直接报错；
2. 【allkeys-lru】所有key通⽤，优先删除最少使⽤的key；
3. 【volatile-lru】所有设置过期的key，优先删除最少使⽤的key；
4. 【allkeys-random】所有key通⽤，随机删除⼀部分key；
5. 【volatile-random】所有设置过期的key，随机删除⼀部分key；
6. 【volatile-ttl】所有设置过期的key，删除剩余时间(Time to live)最少的key。

### 8、说说Redis中持久化机制？

Redis持久化是把内存中的数据同步到硬盘文件中，当Redis重启后再将硬盘文件内容重新加载到内存以实现数据恢复的目的。

具体持久化机制是单独fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。

具体持久化方式，分别为RDB和AOF方式。

### 9、Redis持久化 RDB 机制与 AOF 机制的区别？

* RDB持久化：是Redis默认的持久化方式，即按照一定的时间周期策略把**内存的数据**以快照的形式保存到硬盘的二进制文件。即**快照存储**，对应产生的数据文件为`dump.rdb`
* AOF持久化：以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录。以文本的方式记录，可以打开文件看到详细的操作记录。

简单理解，一个是记录内存数据的副本，一个是记录增、删的操作流水。

### 10、Redis缓存穿透怎么解决？

* **缓存穿透**：指缓存和数据库中都没有的数据。这样每次请求都会去查库，同时数据库中也没有查到该数据，也没法放入缓存。
    1. 缓存空对象
    2. 布隆过滤器(Bloom Filter)
* **缓存击穿**：指一个 key 非常热点，在不停的扛着大并发。当这个 key 在失效的瞬间，持续的大并发就击穿缓存，瞬时请求到数据库。
    1. 加锁，同一时刻只有一个请求能访问数据库
    2. 缓存自动续期 或者 永不过期
* **缓存雪崩**：缓存击穿的升级版，有多个热门key同时失效。
    1. 过期时间加随机数，避免多个key同时过期
    2. 如果缓存服务down机，服务降级

参考：https://blog.csdn.net/lzy194/article/details/122231010

### 11、Redis常用管理命令

```
set key value 设置值
mset key1 value1 key2 value2  批量设置值
setnx key value  键必须不存在，才能设置成功，用于添加
set key value xx 键必须存在，才能设置成功，用于更新
get key  获取值
mget key1 key2  批量获取值

keys * 查看所有键
exists key 检查键是否存在
del key 删除键
expire key seconds  设置过期时间
ttl key  查看还剩多久过期
type key 查看键的数据结构类型

dbsize 返回当前数据库 key 的数量。
info 返回当前 redis 服务器状态和一些统计信息。
monitor 实时监听并返回redis服务器接收到的所有请求信息。 
shutdown 把数据同步保存到磁盘上，并关闭redis服务。
config get parameter 获取一个 redis 配置参数信息。（个别参数可能无法获取）
config set parameter value 设置一个 redis 配置参数信息。（个别参数可能无法获取）
config resetstat 重置 info 命令的统计信息。（重置包括：keyspace 命中数、
keyspace 错误数、 处理命令数，接收连接数、过期 key 数）
debug object key 获取一个 key 的调试信息。
debug segfault 制造一次服务器当机。
flushdb 删除当前数据库中所有 key,此方法不会失败。小心慎用
flushall 删除全部数据库中所有 key，此方法不会失败。小心慎用
```

### 12、Redis如何实现分布式锁？

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。

那么，如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？

set指令可以指定 ex 参数，即可以把setnx和expire合成一条指令来执行。

### 13、使用过 Redis 做消息队列么，你是怎么用的？

可以使用Redis的 list 数据结构来作为消息队列，但是存在一些问题。参考：https://blog.csdn.net/skye_fly/article/details/119887440

### 14、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？

使用**keys指令**可以扫出指定模式的key列表。

对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用**scan指令**，scan指令可以**无阻塞**的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

### 15、MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？

这个面试题其实考察的是redis的淘汰机制。

限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。
所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制 maxmemory(单位是byte字节)参数、maxmemory-policy(过期策略)参数。

